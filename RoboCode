#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  clawEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  eleEncoderLeft, sensorNone)
#pragma config(Sensor, I2C_3,  eleEncoderRight, sensorNone)
#pragma config(Motor,  port1,						middleWheel,	 tmotorVex393_HBridge, openLoop)				
#pragma config(Motor,  port2,           theClaw,       tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           leftMotorB,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightMotorB,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           eleMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           eleMotor2,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           eleMotor3,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          eleMotor4,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c" //Main competition background code...do not modify!
 
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// The next 8 lines are Kavner's advanced thing that makes the robot a tiny bit less sensitive
// to the joysticks
int deadBand(int joyVal){
	if(joyVal < 9.76 && joyVal > -9.76){
		return 0;
	}
	return ((abs(joyVal) - 9.76) / 117.24 * 127) * (joyVal / abs(joyVal));
}

int a = 1;

//all of these are methods that are just simple ways of making a lot of stuff happen, their names are
//pretty self explanatory
void eleUp()
	{
		motor[eleMotor] = -110;
		motor[eleMotor2] = 110;
		motor[eleMotor3] = 110;
		motor[eleMotor4] = 110;
	}
void eleDown()
	{
		motor[eleMotor] = 110;
		motor[eleMotor2] = -110;
		motor[eleMotor3] = -110;
		motor[eleMotor4] = -110;
	}
void eleStop()
{
		motor[eleMotor] = -20;
		motor[eleMotor2] = 20;
		motor[eleMotor3] = 20;
		motor[eleMotor4] = 20;
}
void motorGo()
{
	motor[leftMotor] = 100;
	motor[leftMotorB] = 100;
	motor[rightMotor] = -127;
	motor[rightMotorB] = -127;
}
void motorGoBack()
{
	motor[leftMotor] = -100;
	motor[leftMotorB] = -100;
	motor[rightMotor] = 127;
	motor[rightMotorB] = 127;
}
void motorStop()
{
	motor[leftMotor] = 0;
	motor[leftMotorB] = 0;
	motor[rightMotor] = 0;
	motor[rightMotorB] = 0;
}
void motorTurnLeft()
{
	motor[leftMotor] = -127;
	motor[leftMotorB] = -127;
	motor[rightMotor] = -127;
	motor[rightMotorB] = -127;
}
void motorTurnRight()
{
	motor[leftMotor] = 127;
	motor[leftMotorB] = 127;
	motor[rightMotor] = 127;
	motor[rightMotorB] = 127;
}
//"Clawio" is the task that makes everything the clas needs to do happen
task Clawio()
{
//the while loop starts the code off, and makes it loop endlessly
//thus always checking for when a button is pressed
	while(a==1)
	{
//if the button labeled 6U on the second controller is pressed
	if(vexRT[Btn6UXmtr2] == 1)
		{
			motor[theClaw] = 127;
		}
//else if the button labeled 6D on the second controller is pressed
		else if(vexRT[Btn6DXmtr2] == 1)
		{
			motor[theClaw] = -127;
		}
//else if nothing is being pressed
		else
		{
			motor[theClaw] = 0;
	  }
	}
// the next few llines are not being used, but they would have acted as a claw-toggle (dont think it works)
/*	int counter = 1;
	int clawValue = 270;
  	if(vexRT[Btn6UXmtr2] == 1){
		counter = counter + 1;
		}else if(vexRT[Btn6UXmtr2] == 0){
		counter = counter;
	}

	if (counter % 2 == 0)
	{
		if (SensorValue[clawEncoder] <= clawValue)
		{
			motor[theClaw] = 60;
		}
		else
		{
			motor[theClaw] = 0;
		}
	}
	else if(counter % 2 == 1)
	{
		if(SensorValue[clawEncoder] >= clawValue)
		{
			motor[theClaw] = -60;
		}
		else
		{
			motor[theClaw] = 0;
		}
	}
*/
}
//"wheelios" is the task that has all of the code for the wheels, at the bottom I'll explain what tasks do
task Wheelios()
{
//while loop continually checks for input from the controller
	while(a==1)
	{
//ill give a better breakdown of the code in the if statement
// "btn" means button, "7D" specifies which button, and adding "Xmtr2" means I'm reffering to the second controller
// the next 10 or so lines are autonomous, but I made it so i could press button 7D to test it out
		if(vexRT[Btn7DXmtr2] == 1)
		{

		motorGo();
		wait1Msec(1200);
		motorTurnRight();
		wait1Msec(500);
		motorGo();
		wait1Msec(1200);
		motorTurnRight();
		wait1Msec(500);
		motorGo();
		wait1Msec(1200);
		motorTurnRight();
		wait1Msec(250);
		motorGo();
		wait1Msec(750);
		motorGoBack();
		wait1Msec(500);
		motorStop();
		}
		int division = 1;
// this if statement makes it so when button 6D is pressed, the speed of the wheels are only 1/4 the normal speed
		if(vexRT[Btn6D] == 0)
		{		// different speeds of wheels
			division = 1;
		}
		else if(vexRT[Btn6D] == 1)
		{
			division = 4;
		}

//makes the joystick work
//the deadBand word is from the very top, its Kavner's complicated logic stuff so dont bother trying to understand it
//vexRt[Ch3] and vexRT[Ch1] make the joystick channels work. aka left and right on one stick, and up and down on the other
		int yAxis = deadBand(vexRT[Ch3]);
		int xAxis = deadBand(vexRT[Ch1]);
		int strafe = deadBand(vexRT[Ch4]);
		int leftSide = (-yAxis - xAxis) / division;
		int rightSide = (-yAxis + xAxis) / division;
// the next 6 lines prevent the wheels from ever exceeding the max power and causing the motors to burn out
		if(abs(leftSide) > 127){
			leftSide = 127 * (leftSide / abs(leftSide));
		}
		if(abs(rightSide) > 127){
			rightSide = 127 * (rightSide / abs(rightSide));
		}
//about 8 lines up the "leftSide" and "rightSide" integer variables were made, now we are assigning them to the correct motors
		motor[leftMotor] = -leftSide;
		motor[leftMotorB] = -leftSide;
		motor[rightMotor] = -rightSide;
		motor[rightMotorB] = rightSide;
		motor[middleWheel] = strafe;
	}
}

//the final task, the elevator task
task Elevatorio(){

	while(1==1)
	{
//		int lowHeight, midHeight, highHeight;
//this if statement is similar to the claw one towards the top, when you press one button the motors go
//full speed forwards, when you press a different button the motors go full speed backwards, and when nothing
//is pressed, the motors do nothing.
		if(vexRT[Btn5UXmtr2] == 1)
		{
			eleUp();
		}
		else if(vexRT[Btn5DXmtr2] == 1)
		{
			eleDown();
		}
		else
		{
			eleStop();
	  }

	  /*
//this long and complicated code makes it so you can press a button and the elevators will go to a specific height, not quite done
		if(vexRT[Btn8UXmtr2] == 1)
		{
			while(SensorValue[eleEncoderLeft] != highHeight || SensorValue[eleEncoderRight] != highHeight )
			{
				if(SensorValue[eleEncoderLeft] > highHeight || SensorValue[eleEncoderRight] > highHeight)
				{
					eleDown();
				}
				else if(SensorValue[eleEncoderLeft] < highHeight || SensorValue[eleEncoderRight] < highHeight )
				{
					eleUp();
				}
				else
				{
					motor[eleMotor] = 0;
				}
			}
		}
		else if(vexRT[Btn8RXmtr2] == 1)
		{
			while(SensorValue[eleEncoderLeft] != midHeight || SensorValue[eleEncoderRight] != midHeight)
			{
				if(SensorValue[eleEncoderLeft] > midHeight || SensorValue[eleEncoderRight] != midHeight)
				{
					eleDown();
				}
				else if(SensorValue[eleEncoderLeft] < midHeight || SensorValue[eleEncoderRight] < midHeight)
				{
					eleUp();
				}
				else
				{
					motor[eleMotor] = 0;
				}
			}
		}
		else if(vexRT[Btn8DXmtr2] == 1)
		{
			while(SensorValue[eleEncoderLeft] != lowHeight || SensorValue[eleEncoderRight] != lowHeight)
			{
				if(SensorValue[eleEncoderLeft] > lowHeight || SensorValue[eleEncoderRight] > lowHeight)
				{
					eleDown();
				}
				else if(SensorValue[eleEncoderLeft] < lowHeight || SensorValue[eleEncoderRight] < lowHeight)
				{
					eleUp();
				}
				else
				{
					motor[eleMotor] = 0;
				}
			}
		}
*/
	}
//this is the "before autonomous" method that clears our encoders, we dontt use them yet but this will help us in the future
}
void pre_auton()
{
	SensorValue(eleEncoderLeft) = 0;
	SensorValue(eleEncoderRight) = 0;
	SensorValue(leftEncoder) = 0;
	SensorValue(rightEncoder) = 0;
}
//this task is run by the competition people during autonomous
task autonomous()
{
		motorGo();
		wait1Msec(1200);
		motorTurnRight();
		wait1Msec(500);
		motorGo();
		wait1Msec(1200);
		motorTurnRight();
		wait1Msec(500);
		motorGo();
		wait1Msec(1200);
		motorTurnRight();
		wait1Msec(250);
		motorGo();
		wait1Msec(750);
		motorGoBack();
		wait1Msec(500);
		motorStop();

}
//so here's how tasks work:
/*
Normally code just runs vertically down, line by line, but that means only one thing can happen at a time,
so we would not be able to make the robot go forward while moving the elevator up or down etc. What tasks do is
run the code on multiple lines at once, and thus letting different stuff happen at the same time. the next 7 lines or so
is our "main method". it starts all of our tasks, and then for some reason you have to have an empty while loop after it,
i dont question why, but it works
*/
task usercontrol()
{
	startTask(Elevatorio);
	startTask(Wheelios);
	startTask(Clawio);
	while(a == 1)
	{
	}
}



/*  int counter = 1;
if(BTN6U == 1){
counter = counter + 1;
}else if(BTN6U == 0){
counter = counter;
}

if (counter % 2 == 0){
division == 4;
}else if(counter % 2 == 1){
division == 1;
}
*/

/*
boolean apples = true;
if(BTN6U == 1 && apples == true){
apples == false;
} else if( BTN6U == 1 && apples == false){
apples == true;
}
if(apples == true){
division == 1;
} else if (apples == false){
division == 4;
}

*/

/*
// clears the encoders' counts
nMotorEncoder[leftEnconder] = 0;
nMotorEncoder[rightEncoder] = 0;

if (leftEnconder > rightEncoder){
leftMotor == 110;
leftMotorB == 110;
rightMotor == 127;
rightMotor == 127;
} else if (rightEncoder > leftEnconder){
rightMotor == 110;
rightMotorB == 110;
leftMotor == 127;
leftMotorB;
} else{
leftMotor == 127;
leftMotorB == 127;
rightMotor == 127;
rightMotor == 127;

}



//timer by diego:
wait1Msec
task main()
{
Motor[port]= 1;
/\
motor[theClaw]
wait1Msec(time);
(waitmillisecs)
/\
I dont know what im doing - Diego, Nick doesnt agrees -Nick :(



*/

// Xmtr2, Ch2Xmtr2 vexRT[Btn6DXmtr2]
